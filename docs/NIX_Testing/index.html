<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>NIX_Testing API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>NIX_Testing</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from astropy.io import fits
from astropy.visualization import ImageNormalize, PercentileInterval
import numpy as np
import sep
import os
from matplotlib.patches import Ellipse
import matplotlib.pyplot as plt
import time
from IPython.display import clear_output
from scipy.stats import linregress
from scipy.special import jv
from scipy.optimize import leastsq
from ccdproc import cosmicray_lacosmic
from NIX_Testing.HDRL import compute_strehl
import multiprocessing as mp
import pickle
import re

class NIX_Base(object):

    __slots__ = (&#39;full_path&#39;, &#39;f_name&#39;, &#39;header&#39;, &#39;test_id&#39;)

    def __init__(self, path, test_id=None, verbose=False):

        if verbose:
            print(&#34;Loading file &#34; + path.split(&#39;/&#39;)[-1])
        self.f_name = path.split(&#39;/&#39;)[-1]
        self.full_path = path
        #self.header = fits.getheader(path)
        if test_id is not None:
            self.test_id = test_id
        else:
            self.test_id = None

    def getImage(self, hdu=None, mask=None, dark=None, linearize=False, gain=None):

        hdul = fits.open(self.full_path)
        image = hdul[0].data*1. 
        hdul.close()
        # Handle exception where data format is (1, 2048, 2048)
        if image.shape[0] == 1:
            image = image[0,:,:]

        if dark is not None:
            image = image - dark.getImage()
        if linearize:
            image = self.linearize(image)
        if mask is not None:
            image = image * mask.getImage()
        if gain is not None:
            image *= gain
        return image

    def linearize(self, image):
        f = open(&#39;linearity_coef&#39;, &#39;rb&#39;)
        pol = np.poly1d(pickle.load(f))
        f.close()

        image = pol(image)

        return image

    def plotImage(self, mask=None, dark=None):

        plt.imshow(self.getImage(mask=mask, dark=dark))
        plt.gca().invert_yaxis()
        plt.show()

class NIX_Spectra(NIX_Base):
    
    def _singleLineFit(self, xx, yy, window=10):

        from lmfit.models import GaussianModel, ConstantModel

        model = GaussianModel()+ConstantModel()
        pars = ConstantModel().make_params()
        pars += GaussianModel().guess(yy, x=xx)
        out = model.fit(yy, pars, x=xx)

        return out

    def _multiLineFitFromTable(self, nlines=20):

        import pandas as pd
        from lmfit.models import GaussianModel, LorentzianModel

        line_data = pd.read_csv(&#39;data/ThAr_lines.csv&#39;, header=None)
        line_data = line_data.sort_values(4, ascending=False)
        line_data = np.array(line_data[2])

        line_data = line_data[np.where((line_data &gt; 3090) &amp; (line_data &lt; 3900))[0]]

        plt.figure(figsize=(16,4))

        model_l = []

        for i in range(nlines):

            model = GaussianModel(prefix=&#34;l%02d_&#34; % i)
            model_l.append(model)

            if i == 0:
                pars = model.make_params()
            else:
                pars.update(model.make_params())

            #print pars
            plt.plot([line_data[i], line_data[i]], [0, 1e6], &#39;k--&#39;)

            pars[&#39;l%02d_center&#39; % i].set(value=line_data[i], 
                min=(line_data[i]-1.), max=(line_data[i]+1.))
            pars[&#39;l%02d_sigma&#39; % i].set(value=1.4, max=2.5, min=1.)
            pars[&#39;l%02d_amplitude&#39; % i].set(value=1e6)

        print(&#34;%20s %20s %20s&#34; % (&#34;Original(nm)&#34;, &#34;Measured(nm)&#34;, &#34;FWHM(nm)&#34;))
        for i in range(nlines):
            if i == 0:
                mod = model_l[i]
            else:
                mod += model_l[i]
 
        init = mod.eval(pars, x=self.wave)
        out=mod.fit((self.spectra1d-self.continuum(self.wave)), pars, x=self.wave)

        for i in range(nlines):
            print(&#34;%20.2f %20.2f %20.5f&#34; % (line_data[i], 
                out.best_values[&#34;l%02d_center&#34; % i], out.best_values[&#34;l%02d_sigma&#34; % i]*2.35))


        #print out.fit_report()
        plt.plot(self.wave, out.best_fit)
        plt.plot(self.wave, self.spectra1d - self.continuum(self.wave))
        plt.show()

    def _polFit(self, xx, yy, order):

        from lmfit.models import PolynomialModel

        model = PolynomialModel(order)
        pars = model.guess(yy, x=xx)
        out = model.fit(yy, pars, x=xx)
        
        return out

    def _continuumFit(self, method=&#39;polynomial&#39;, order=5, smooth=6):

        import pandas as pd

        line_data = pd.read_csv(&#39;data/ThAr_lines.csv&#39;, header=None)
        line_data = line_data.sort_values(4, ascending=False)
        line_data = np.array(line_data[2])

        self.spectraFiltered = self.spectra1d
        self.waveFiltered = self.wave

        for i in range(50):
            ndx = np.where(np.abs(self.waveFiltered - line_data[i]) &lt; 5)[0]
            self.spectraFiltered = np.delete(self.spectraFiltered, ndx)
            self.waveFiltered = np.delete(self.waveFiltered, ndx)
            #plt.plot([line_data[i], line_data[i]], [0, 1.2e6], &#39;r--&#39;)

        if method == &#34;polynomial&#34;:
            from lmfit.models import PolynomialModel
            model = PolynomialModel(order)
            pars = model.guess(self.spectraFiltered, x=self.waveFiltered)
            out = model.fit(self.spectraFiltered, pars, x=self.waveFiltered)
            self.continuum = np.poly1d([out.best_values[&#39;c%d&#39; % i] for i in range(order+1)[::-1]])
        elif method == &#34;spline&#34;:
            from scipy.interpolate import UnivariateSpline
            self.continuum = UnivariateSpline(self.waveFiltered, self.spectraFiltered, 
                w=1/self.spectraFiltered, k=order, s=smooth)

    def getOrderTracing(self, bright_line=None, mask=None, dark=None):

        window = 10

        if bright_line is not None:
            image = self.getImage(mask=mask, dark=dark)
            xys = bright_line[&#39;xys&#39;]
            centers = []
            plt.figure(figsize=(4*2, 4))
            for i in range(2):
                yy = image[xys[i][1]-window:xys[i][1]+window, xys[i][0]]
                xx = np.arange(xys[i][1]-window,xys[i][1]+window)
                out = self._singleLineFit(xx, yy, window=window) 
                centers.append(out.best_values[&#39;center&#39;])

                plt.subplot(1,2,i+1)
                plt.plot(xx, yy, &#39;k&#39;)
                plt.plot(xx, out.best_fit, &#39;r&#39;)

            plt.show()
            
        self.A = (centers[1]-centers[0])/(xys[1][0] - xys[0][0])

    def getSpectra1D(self, bright_line=None, mask=None, dark=None):

        if not hasattr(self, &#39;A&#39;):
            self.getOrderTracing(bright_line=bright_line, mask=mask, dark=dark)

        image = self.getImage(mask=mask, dark=dark)

        X = np.arange(2048)
        XX, YY = np.meshgrid(X, X)

        B = YY-self.A*XX
        B = np.floor(B).astype(int)

        spec1d = np.zeros(2048)

        for i in range(2048):
            for j in range(600, 1600):
                spec1d[B[i,j]] += image[i,j]

        plt.figure(figsize=(16, 4))

        plt.plot(X, spec1d)
        plt.show()

        self.spectra1d = spec1d

    def subtractContinuum(self, method=&#39;polynomial&#39;, order=5, smooth=6):

        plt.figure(figsize=(16, 4))
        out = self._continuumFit(method=method, order=order, smooth=smooth)

        plt.title(&#39;Continuum Model&#39;)
        plt.plot(self.wave, self.spectra1d)
        plt.plot(self.wave, self.continuum(self.wave))
        plt.show()
 
        plt.figure(figsize=(16, 4))
        plt.title(&#39;Continuum Subtracted&#39;)
        plt.plot(self.wave, self.spectra1d - self.continuum(self.wave))
        plt.show()

    def calibrate(self, ref_lines=None, mask=None, dark=None, order=2):
        
        window = 10

        if ref_lines is not None:
            image = self.getImage(mask=mask, dark=dark)
            sz = len(ref_lines)
            plt.figure(figsize=(4*sz, 4))
            xs = [ref_line[&#39;x&#39;] for ref_line in ref_lines]
            waves = [ref_line[&#39;wave&#39;] for ref_line in ref_lines]
            for i in range(sz):
                yy = self.spectra1d[xs[i]-window:xs[i]+window]
                xx = np.arange(xs[i]-window,xs[i]+window)
                out = self._singleLineFit(xx, yy, window=window) 
                xs[i] = out.best_values[&#39;center&#39;]

                plt.subplot(1,sz,i+1)
                plt.plot(xx, yy, &#39;k&#39;)
                plt.plot(xx, out.best_fit, &#39;r&#39;)

            plt.show()
        
        out = self._polFit(xs, waves, order=order)

        print(out.fit_report())

        xx = np.arange(2048)
        
        waveSol = np.poly1d(out.best_values.values())
        self.wave = waveSol(xx)

        plt.figure(figsize=(16, 4))
        plt.plot(self.wave, self.spectra1d)
        plt.show()

    def extract(self, ref_lines, mask=None, dark=None):
        
        spectra2d = self.getImage(mask=mask, dark=dark)
        self.plotImage(mask=mask, dark=dark)




class NIX_Image(NIX_Base):

    def getMedian(self, dark=None, mask=None):

        if not hasattr(self, &#39;median&#39;):
            image = self.getImage(mask=mask, dark=dark)
            self.median = np.median(image)
        return self.median

    def getObjects(self, mask=None, search=None, thresh=500, minarea=20, force=False):
        
        if not hasattr(self, &#39;objects&#39;) or force:
            image = self.getImage(mask=mask)
            self.objects = sep.extract(image, thresh, minarea=minarea)

        if search is None:
            return self.objects
        else:
            # Caution. This will return first found object within the search radius
            for object in self.objects:
                if ((object[&#39;x&#39;] - search[&#39;x&#39;])**2 + (object[&#39;y&#39;] - search[&#39;y&#39;])**2 &lt; search[&#39;r&#39;]**2):
                    return object

    
    def plotDistortionPSF(self, grid=5, perc=95, mask=None, dark=None, linearize=False, title=None, clean=True, strehl=True, strehlWave=2.2, out_ims=None):

        objects = self.getObjects()
        im_sz = 30

        xs = np.array([obj[&#39;x&#39;] for obj in objects])
        ndxs = xs.argsort()
        objects = objects[ndxs]

        for i in range(grid):
            ys = np.array([obj[&#39;y&#39;] for obj in objects[grid*i:grid*(i+1)]])
            ndxs = ys.argsort()
            objects[grid*i:grid*(i+1)] = objects[grid*i:grid*(i+1)][ndxs]

        fig, axs = plt.subplots(grid, grid, figsize=(12,12))

        im = np.zeros([2048+2*im_sz, 2048+2*im_sz])
        im[im_sz:im_sz+2048, im_sz:im_sz+2048] = self.getImage(mask=mask, dark=dark, linearize=linearize)

        norm_im = ImageNormalize(im, interval=PercentileInterval(perc))

        if clean:
            im = badPixelInterpolate(im)

        strehl_str = &#39;&#39;
        fwhm_str = &#39;&#39;

        for i in range(grid):
            for j in range(grid):
                obj = objects[grid*j+i]
                x_c, y_c = int(obj[&#39;x&#39;])+im_sz, int(obj[&#39;y&#39;])+im_sz

                crop_im = im[y_c-im_sz:y_c+im_sz, x_c-im_sz:x_c+im_sz]
                if strehl:
                    airy_rad = 1.22*strehlWave*1e-6/8./np.pi*180.*60.*60.
                    strehl, crop_im, sig3 = strehlRatio(crop_im, strehlWave)
                    crop_im, _ = cosmicray_lacosmic(crop_im)
                    if out_ims is not None:
                        fits.PrimaryHDU(crop_im).writeto(out_ims % (grid-1-i, j), overwrite=True)
                    #strehl = HDRL_strehl(out_ims % (grid-1-i, j), strehlWave, 8./2., 1.116/2., 13., airy_rad, airy_rad*3, airy_rad*4)
                    strehl = HDRL_strehl2(crop_im, strehlWave, 8./2., 1.116/2., 13., airy_rad, airy_rad*3, airy_rad*4)
                    axs[grid-1-i][j].set_title(&#34;%.3f&#34; % strehl)
                
                strehl_str += &#39;%.4f &#39; % strehl 
                fwhm_str += &#39;%2.6f &#39; % (sig3/3.*2.35) 

                axs[grid-1-i][j].imshow(crop_im, cmap=&#39;gray&#39;, norm=norm_im)
                axs[grid-1-i][j].invert_yaxis()
                axs[grid-1-i][j].get_yaxis().set_ticks([])
                axs[grid-1-i][j].get_xaxis().set_ticks([])

            strehl_str += &#39;\n&#39;
            fwhm_str += &#39;\n&#39;

        if title is not None:
            fig.suptitle(title)

        return strehl_str, fwhm_str

    def plotObjects(self, mask=None, figsize=None):

        if figsize is not None:
            fig, ax = plt.subplots(figsize=figsize)
        else:
            fig, ax = plt.subplots()

        ax.imshow(self.getImage(mask=mask))
        ax.invert_yaxis()

        for object in self.objects:
        
            e = Ellipse(xy=(object[&#39;x&#39;], object[&#39;y&#39;]),
                        width=6*object[&#39;a&#39;],
                        height=6*object[&#39;b&#39;],
                        angle=object[&#39;theta&#39;] * 180. / np.pi)
            e.set_facecolor(&#39;none&#39;)
            e.set_edgecolor(&#39;red&#39;)
            ax.add_artist(e)
        
        plt.ylim([0, 2048])
        plt.xlim([0, 2048])
        plt.show()


class NIX_Image_List:

    def __init__(self, config):

        self.NIX_Files = []
        self.config = config
        self.loadFiles()
        self.Filtered = self.NIX_Files

    def __getitem__(self, ndx):

        return self.Filtered[ndx]

    def __len__(self):

        return len(self.Filtered)

    def loadFiles(self):

        if &#39;prefix&#39; in self.config:
            prefix = True
        else:
            prefix = False

        if &#39;test_ids&#39; in self.config:

            for test_id in self.config[&#39;test_ids&#39;]:
                full_path = self.config[&#39;data_dir&#39;] + &#39;/&#39;+ (&#39;%s-%s&#39; % tuple(test_id.split(&#39;-&#39;)[:2])) + &#39;/&#39; + test_id + &#39;/&#39;
                files = os.listdir(full_path)
                files.sort()

                for f_name in files:
                    if prefix:
                        if f_name.startswith(self.config[&#39;prefix&#39;]) and f_name.endswith(&#39;fits&#39;):
                            self.NIX_Files.append(NIX_Image(full_path + f_name, test_id=test_id))                        
                    else:
                        if f_name.endswith(&#39;fits&#39;):
                            self.NIX_Files.append(NIX_Image(full_path + f_name, test_id=test_id))

        else:

            full_path = self.config[&#39;data_dir&#39;] + &#39;/&#39;
            files = os.listdir(full_path)
            files.sort()

            for f_name in files:
                    if prefix:
                        if f_name.startswith(self.config[&#39;prefix&#39;]) and f_name.endswith(&#39;fits&#39;):
                            self.NIX_Files.append(NIX_Image(full_path + f_name))                        
                    else:
                        if f_name.endswith(&#39;fits&#39;):
                            self.NIX_Files.append(NIX_Image(full_path + f_name))
    

    def printTable(self, keywords, tbl_fmt):

        table_header =  [&#39;NDX&#39;, &#39;TEST_ID&#39;, &#39;FILENAME&#39;]
        table_header.extend([strip_prefix_from_keyword(keyword) for keyword in keywords])
        print((&#39;%4s&#39; + tbl_fmt) % tuple(table_header))
        
        ctr = 0 
        for File in self.NIX_Files:
            header = fits.getheader(File.full_path)
            out_list = [ctr, File.test_id, File.f_name]
            try:
                out_list.extend([header[keyword] for keyword in keywords])
                print((&#39;%04d&#39; + tbl_fmt) % tuple(out_list))
            except:
                out_list.extend(None for keyword in keywords)
                print((&#39;%04d&#39; + tbl_fmt) % tuple(out_list))
            ctr += 1

    def printFiltered(self, keywords, tbl_fmt):

        table_header =  [&#39;NDX&#39;, &#39;TEST_ID&#39;, &#39;FILENAME&#39;]
        table_header.extend([strip_prefix_from_keyword(keyword) for keyword in keywords])
        print((&#39;%4s&#39; + tbl_fmt) % tuple(table_header))
        
        ctr = 0 
        for File in self.Filtered:
            header = fits.getheader(File.full_path)
            out_list = [ctr, File.test_id, File.f_name]
            try:
                out_list.extend([header[keyword] for keyword in keywords])
                print((&#39;%04d&#39; + tbl_fmt) % tuple(out_list)) 
            except:
                out_list.extend(None for keyword in keywords)
                print((&#39;%04d&#39; + tbl_fmt) % tuple(out_list))
            ctr += 1


    # revisit later on for filtering data
    def filter(self, val):
        if isinstance(val, slice):
            self.Filtered = self.NIX_Files[val]

    def medianCombine(self, out=None):

        sz = len(self.Filtered)
        ims = np.zeros([2048, 2048, sz])

        for i in range(len(self.Filtered)):
            ims[:,:,i] = self.Filtered[i].getImage()

        if out is not None:
            fits.PrimaryHDU(np.median(ims, axis=2)).writeto(out, overwrite=True)
        
        return np.median(ims, axis=2)

    # very crude BP mask generation to be revisited later on
    def doBadPixelMask(self, thresh=20, out=None):
        
        im = self.medianCombine()

        im[np.where(im &lt; thresh)] = 1
        im[np.where(im &gt;= thresh)] = 0

        if out is not None:
            fits.PrimaryHDU(im).writeto(out, overwrite=True)
        
        return im

    def doLinearRegress(self, exps, select, cpu=1, dark=None, mask=None):

        sz = exps.shape[0]

        exps = np.tile(exps, 2048*2048)
        exps = exps.reshape([2048, 2048, sz])

        ims = self.getImage(select=select, mask=mask, dark=dark)

        angs, lins, Rs = self._multiLinearRegress(exps, ims, cpu=cpu)

        return angs, lins, Rs

    def getMedian(self, mask=None, dark=None):

        return [NI.getMedian(mask=mask, dark=dark) for NI in self.Filtered]

    def getImage(self, select=None, mask=None, dark=None):

        if select is not None:
            sz = select.shape[0]
        else:
            sz = len(self.Filtered)
        ims = np.zeros([2048, 2048, sz])

        if dark is None:
            darks = [None]*sz
        else:
            darks = [self.Filtered[i] for i in range(sz)]

        if select is not None:
            for i in range(sz):
                ims[:,:,i] = self.Filtered[select[i]].getImage(mask=mask, dark=darks[i])
        else:
            for i in range(sz):
                ims[:,:,i] = self.Filtered[i].getImage(mask=mask, dark=darks[i])

        return ims

    def getPixelVariance(self, mask=None, shift=True, gain=None):

        sz = len(self.Filtered)
        data = np.zeros([2048, 2048, sz])
        diff = np.zeros([2048, 2048, sz])

        for i in range(sz):
            data[:,:,i] = self.Filtered[i].getImage(mask=None, gain=gain)
            diff[:,:,i] = data[:,:,i] - data[:,:,0]
            diff[:,:,i] = np.median(diff[:,:,i])

        if shift:
            data[:,:,:] -= diff

        return np.var(data, axis=2, ddof=1), diff[0,0,:]

    def getObjects(self, mask=None, search=None, sepdict=None, thresh=500, minarea=20, force=False):
        
        if sepdict is not None:
            return [NI.getObjects(mask=mask, search=search, thresh=thresh, minarea=minarea, force=force)[sepdict] for NI in self.Filtered]
        else:
            return [NI.getObjects(mask=mask, search=search, thresh=thresh, minarea=minarea, force=force) for NI in self.Filtered]

    def getHeaderValue(self, keyword):

        return [fits.getheader(NI.full_path)[keyword] for NI in self.Filtered]

    def _multiLinearRegress(self, data1, data2, cpu=1):

        pb = ProgressBar(function=&#34;_multiLinearRegress&#34;)
        angs = np.zeros([2048, 2048])
        lins = np.zeros([2048, 2048])
        Rs = np.zeros([2048, 2048])
        pool = mp.Pool(cpu)
        for i in range(2048):
            arr1s = [data1[i,j,:] for j in range(2048)]
            arr2s = [data2[i,j,:] for j in range(2048)]
            out = pool.map(_singleLinearRegress, zip(arr1s, arr2s))
            for j in range(2048):
                angs[i,j], lins[i,j], Rs[i,j] = out[j][0], out[j][1], out[j][2]
            
            pb.report(i+1, 2048)

        return angs, lins, Rs


# Some utility functions
def strip_prefix_from_keyword(keyword):

    if keyword.startswith(&#39;HIERARCH ESO&#39;):
        keyword = keyword[13:]

    keyword = &#39;_&#39;.join(keyword.split(&#39; &#39;))
    return keyword

def Gaussian2D(p, x, y):
    return p[0]*np.exp(-((x-p[1])**2+(y-p[2])**2)*0.5/p[3]**2)+p[4]

def Gaussian2D_errf(p, x, y, z):
    return z-Gaussian2D(p, x, y)

def strehlRatio(image, strehlWave):

    sz = image.shape[0]

    sum_diff, diff = getDiffractionPattern(strehlWave, 13.)

    XX = np.arange(sz)
    XX, YY = np.meshgrid(XX, XX)
    x0 = [1e4, sz/2., sz/2., 2., 0.]

    ndx = np.where(~np.isnan(image))

    out = leastsq(Gaussian2D_errf, x0, args=(XX[ndx].flatten(), 
        YY[ndx].flatten(), image[ndx].flatten()), full_output=True)

    #print out

    x, y, sig = out[0][1], out[0][2], out[0][3]

    ndx_in = np.where(np.sqrt((XX - x)**2+(YY-y)**2) &lt; 3*sig)
    ndx_ann = np.where((np.sqrt((XX - x)**2+(YY-y)**2) &gt; 9*sig))

    backg = np.nanmedian(image[ndx_ann])
    image -= backg
    image[np.where(np.isnan(image))] = 0
    counts = np.sum(image[ndx_in])

    strehl = np.max(image[int(y)-1:int(y)+2,int(x)-1:int(x)+2])/(counts/sum_diff)

    #print y, x, strehl, image[int(y),int(x)], counts, backg, sig

    return strehl, image, 3*sig


def badPixelInterpolate(image, cosmicray=True):

    xsz = image.shape[0]
    ysz = image.shape[1]
    stack = np.zeros([xsz, ysz, 8])
    stack[:,:,0] = np.roll(image, 1, axis=0)
    stack[:,:,1] = np.roll(image, 1, axis=1)
    stack[:,:,2] = np.roll(image, -1, axis=0)
    stack[:,:,3] = np.roll(image, -1, axis=1)
    stack[:,:,4] = np.roll(np.roll(image, 1, axis=0), 1, axis=1)
    stack[:,:,5] = np.roll(np.roll(image, 1, axis=0), -1, axis=1)
    stack[:,:,6] = np.roll(np.roll(image, -1, axis=0), 1, axis=1)
    stack[:,:,7] = np.roll(np.roll(image, -1, axis=0), -1, axis=1)

    stack[np.where(stack == 0)] = np.NaN

    std_stack = np.nanstd(stack, axis=2)
    med_stack = np.nanmedian(stack, axis=2)

    ndx = np.where(image == 0)
    image[ndx] = med_stack[ndx]

    if cosmicray:
        image, _ = cosmicray_lacosmic(image)

    return image

def doGridAnalysis(data, grid, window, start, func, factor=1., index=None):

    sz = data.shape[2]
    result = np.zeros([grid*grid*sz])

    for k in range(sz):
        ndx = index if index is not None else k
        for i in range(grid):
            for j in range(grid):
                result[i*grid*sz+j*sz+k] = func(data[start+window*i:start+window*(i+1),
                            start+window*j:start+window*(j+1), ndx])

    return result*factor

def _singleLinearRegress(args):

    arr1, arr2 = args
    ang, lin, R, _, _ = linregress(arr1, arr2)
    return ang, lin, R

def getDiffractionPattern(wave, plate_scale, D=8, fill=0.14, size=40):

    wave *= 1e-6
    pix = np.arange(size*4+0.1).astype(float)-size*2

    XX, YY = np.meshgrid(pix,pix)

    XX = (XX*plate_scale/4./60./60./180./1000.*np.pi)*np.pi*D/wave
    YY = (YY*plate_scale/4./60./60./180./1000.*np.pi)*np.pi*D/wave

    R = lambda x, y: np.sqrt((x)**2+(y)**2)

    func = lambda x, y, f: (2*jv(1,R(x,y))-2*f*jv(1,f*R(x,y)))**2/((1-f**2)**2*R(x,y)**2)

    im = func(XX, YY, fill)
    im[size*2,size*2] = 1

    return np.sum(im)/16., im

def HDRL_strehl2(image, wave, r1, r2, pixsc, flux_r, bkg_r1, bkg_r2):

    from NIX_Testing.HDRL2 import compute_strehl
    strehl = compute_strehl(image, wave*1e-6, r1, r2, pixsc*1e-3, pixsc*1e-3, flux_r, bkg_r1, bkg_r2) 

    #strehl = compute_strehl(image, wave*1e-6, r1, r2, pixsc*1e-3, flux_r, bkg_r1, bkg_r2) 

    #return strehl
    return strehl.strehl_value.data

def HDRL_strehl(f_name, wave, r1, r2, pix_scale, flux_r, bkg_r1, bkg_r2, path=&#34;/home/ydallilar/Documents/NIX/scripts/NIX_Testing/strehl&#34; ):

    import subprocess
    env = dict(os.environ)
    env[&#39;LD_LIBRARY_PATH&#39;] = path
    cmd = &#34;%s/strehl %s %.10f %.10f %.10f %.10f %.10f %.10f %.10f %.10f&#34; % \
        (path, f_name, wave*1e-6, r1, r2, pix_scale*1e-3, pix_scale*1e-3, flux_r,
        bkg_r1, bkg_r2)
    #print cmd.split()
    #cmd = &#34;ls&#34;
    proc = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    o, _ = proc.communicate()
    o = o.decode(&#39;ascii&#39;).split(&#39;\n&#39;)
    #print o[10]
    #print o[10].split(&#39;()&#39;)[0]
    res = o[10].split(&#39;(&#39;)[0].split(&#39;:&#39;)[1]
    #print res

    return float(res)

class ProgressBar:

    __slots__ = (&#34;t_start&#34;, &#34;function&#34;)

    def __init__(self, function=None):
        self.t_start = time.time()
        if function is not None:
            self.function = function
        else:
            self.function = &#34;&#34;

    def init(self, function=None):
        self.__init__(function=function)

    def report(self, current, full):
        progress = float(current)/full*100
        bar_done = int(round(progress/5.))
        t_now = time.time()
        t_elapsed = t_now-self.t_start
        t_full = t_elapsed/progress*100

        clear_output(wait=True)
        print(&#34;%s ==&gt; [%s%s] %3d%% %s/%s&#34; % (self.function, &#34;#&#34;*bar_done, &#39;-&#39;*(20-bar_done), progress,
            self._formatTime(t_elapsed), self._formatTime(t_full)))

    def _formatTime(self, t):

        mins = t / 60.
        secs = t % 60

        return &#34;%02d:%02d&#34; % (mins, secs)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="NIX_Testing.HDRL" href="HDRL.html">NIX_Testing.HDRL</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="NIX_Testing.Gaussian2D"><code class="name flex">
<span>def <span class="ident">Gaussian2D</span></span>(<span>p, x, y)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Gaussian2D(p, x, y):
    return p[0]*np.exp(-((x-p[1])**2+(y-p[2])**2)*0.5/p[3]**2)+p[4]</code></pre>
</details>
</dd>
<dt id="NIX_Testing.Gaussian2D_errf"><code class="name flex">
<span>def <span class="ident">Gaussian2D_errf</span></span>(<span>p, x, y, z)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Gaussian2D_errf(p, x, y, z):
    return z-Gaussian2D(p, x, y)</code></pre>
</details>
</dd>
<dt id="NIX_Testing.HDRL_strehl"><code class="name flex">
<span>def <span class="ident">HDRL_strehl</span></span>(<span>f_name, wave, r1, r2, pix_scale, flux_r, bkg_r1, bkg_r2, path='/home/ydallilar/Documents/NIX/scripts/NIX_Testing/strehl')</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HDRL_strehl(f_name, wave, r1, r2, pix_scale, flux_r, bkg_r1, bkg_r2, path=&#34;/home/ydallilar/Documents/NIX/scripts/NIX_Testing/strehl&#34; ):

    import subprocess
    env = dict(os.environ)
    env[&#39;LD_LIBRARY_PATH&#39;] = path
    cmd = &#34;%s/strehl %s %.10f %.10f %.10f %.10f %.10f %.10f %.10f %.10f&#34; % \
        (path, f_name, wave*1e-6, r1, r2, pix_scale*1e-3, pix_scale*1e-3, flux_r,
        bkg_r1, bkg_r2)
    #print cmd.split()
    #cmd = &#34;ls&#34;
    proc = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    o, _ = proc.communicate()
    o = o.decode(&#39;ascii&#39;).split(&#39;\n&#39;)
    #print o[10]
    #print o[10].split(&#39;()&#39;)[0]
    res = o[10].split(&#39;(&#39;)[0].split(&#39;:&#39;)[1]
    #print res

    return float(res)</code></pre>
</details>
</dd>
<dt id="NIX_Testing.HDRL_strehl2"><code class="name flex">
<span>def <span class="ident">HDRL_strehl2</span></span>(<span>image, wave, r1, r2, pixsc, flux_r, bkg_r1, bkg_r2)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def HDRL_strehl2(image, wave, r1, r2, pixsc, flux_r, bkg_r1, bkg_r2):

    from NIX_Testing.HDRL2 import compute_strehl
    strehl = compute_strehl(image, wave*1e-6, r1, r2, pixsc*1e-3, pixsc*1e-3, flux_r, bkg_r1, bkg_r2) 

    #strehl = compute_strehl(image, wave*1e-6, r1, r2, pixsc*1e-3, flux_r, bkg_r1, bkg_r2) 

    #return strehl
    return strehl.strehl_value.data</code></pre>
</details>
</dd>
<dt id="NIX_Testing.badPixelInterpolate"><code class="name flex">
<span>def <span class="ident">badPixelInterpolate</span></span>(<span>image, cosmicray=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def badPixelInterpolate(image, cosmicray=True):

    xsz = image.shape[0]
    ysz = image.shape[1]
    stack = np.zeros([xsz, ysz, 8])
    stack[:,:,0] = np.roll(image, 1, axis=0)
    stack[:,:,1] = np.roll(image, 1, axis=1)
    stack[:,:,2] = np.roll(image, -1, axis=0)
    stack[:,:,3] = np.roll(image, -1, axis=1)
    stack[:,:,4] = np.roll(np.roll(image, 1, axis=0), 1, axis=1)
    stack[:,:,5] = np.roll(np.roll(image, 1, axis=0), -1, axis=1)
    stack[:,:,6] = np.roll(np.roll(image, -1, axis=0), 1, axis=1)
    stack[:,:,7] = np.roll(np.roll(image, -1, axis=0), -1, axis=1)

    stack[np.where(stack == 0)] = np.NaN

    std_stack = np.nanstd(stack, axis=2)
    med_stack = np.nanmedian(stack, axis=2)

    ndx = np.where(image == 0)
    image[ndx] = med_stack[ndx]

    if cosmicray:
        image, _ = cosmicray_lacosmic(image)

    return image</code></pre>
</details>
</dd>
<dt id="NIX_Testing.doGridAnalysis"><code class="name flex">
<span>def <span class="ident">doGridAnalysis</span></span>(<span>data, grid, window, start, func, factor=1.0, index=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def doGridAnalysis(data, grid, window, start, func, factor=1., index=None):

    sz = data.shape[2]
    result = np.zeros([grid*grid*sz])

    for k in range(sz):
        ndx = index if index is not None else k
        for i in range(grid):
            for j in range(grid):
                result[i*grid*sz+j*sz+k] = func(data[start+window*i:start+window*(i+1),
                            start+window*j:start+window*(j+1), ndx])

    return result*factor</code></pre>
</details>
</dd>
<dt id="NIX_Testing.getDiffractionPattern"><code class="name flex">
<span>def <span class="ident">getDiffractionPattern</span></span>(<span>wave, plate_scale, D=8, fill=0.14, size=40)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDiffractionPattern(wave, plate_scale, D=8, fill=0.14, size=40):

    wave *= 1e-6
    pix = np.arange(size*4+0.1).astype(float)-size*2

    XX, YY = np.meshgrid(pix,pix)

    XX = (XX*plate_scale/4./60./60./180./1000.*np.pi)*np.pi*D/wave
    YY = (YY*plate_scale/4./60./60./180./1000.*np.pi)*np.pi*D/wave

    R = lambda x, y: np.sqrt((x)**2+(y)**2)

    func = lambda x, y, f: (2*jv(1,R(x,y))-2*f*jv(1,f*R(x,y)))**2/((1-f**2)**2*R(x,y)**2)

    im = func(XX, YY, fill)
    im[size*2,size*2] = 1

    return np.sum(im)/16., im</code></pre>
</details>
</dd>
<dt id="NIX_Testing.strehlRatio"><code class="name flex">
<span>def <span class="ident">strehlRatio</span></span>(<span>image, strehlWave)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strehlRatio(image, strehlWave):

    sz = image.shape[0]

    sum_diff, diff = getDiffractionPattern(strehlWave, 13.)

    XX = np.arange(sz)
    XX, YY = np.meshgrid(XX, XX)
    x0 = [1e4, sz/2., sz/2., 2., 0.]

    ndx = np.where(~np.isnan(image))

    out = leastsq(Gaussian2D_errf, x0, args=(XX[ndx].flatten(), 
        YY[ndx].flatten(), image[ndx].flatten()), full_output=True)

    #print out

    x, y, sig = out[0][1], out[0][2], out[0][3]

    ndx_in = np.where(np.sqrt((XX - x)**2+(YY-y)**2) &lt; 3*sig)
    ndx_ann = np.where((np.sqrt((XX - x)**2+(YY-y)**2) &gt; 9*sig))

    backg = np.nanmedian(image[ndx_ann])
    image -= backg
    image[np.where(np.isnan(image))] = 0
    counts = np.sum(image[ndx_in])

    strehl = np.max(image[int(y)-1:int(y)+2,int(x)-1:int(x)+2])/(counts/sum_diff)

    #print y, x, strehl, image[int(y),int(x)], counts, backg, sig

    return strehl, image, 3*sig</code></pre>
</details>
</dd>
<dt id="NIX_Testing.strip_prefix_from_keyword"><code class="name flex">
<span>def <span class="ident">strip_prefix_from_keyword</span></span>(<span>keyword)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_prefix_from_keyword(keyword):

    if keyword.startswith(&#39;HIERARCH ESO&#39;):
        keyword = keyword[13:]

    keyword = &#39;_&#39;.join(keyword.split(&#39; &#39;))
    return keyword</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="NIX_Testing.NIX_Base"><code class="flex name class">
<span>class <span class="ident">NIX_Base</span></span>
<span>(</span><span>path, test_id=None, verbose=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NIX_Base(object):

    __slots__ = (&#39;full_path&#39;, &#39;f_name&#39;, &#39;header&#39;, &#39;test_id&#39;)

    def __init__(self, path, test_id=None, verbose=False):

        if verbose:
            print(&#34;Loading file &#34; + path.split(&#39;/&#39;)[-1])
        self.f_name = path.split(&#39;/&#39;)[-1]
        self.full_path = path
        #self.header = fits.getheader(path)
        if test_id is not None:
            self.test_id = test_id
        else:
            self.test_id = None

    def getImage(self, hdu=None, mask=None, dark=None, linearize=False, gain=None):

        hdul = fits.open(self.full_path)
        image = hdul[0].data*1. 
        hdul.close()
        # Handle exception where data format is (1, 2048, 2048)
        if image.shape[0] == 1:
            image = image[0,:,:]

        if dark is not None:
            image = image - dark.getImage()
        if linearize:
            image = self.linearize(image)
        if mask is not None:
            image = image * mask.getImage()
        if gain is not None:
            image *= gain
        return image

    def linearize(self, image):
        f = open(&#39;linearity_coef&#39;, &#39;rb&#39;)
        pol = np.poly1d(pickle.load(f))
        f.close()

        image = pol(image)

        return image

    def plotImage(self, mask=None, dark=None):

        plt.imshow(self.getImage(mask=mask, dark=dark))
        plt.gca().invert_yaxis()
        plt.show()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="NIX_Testing.NIX_Spectra" href="#NIX_Testing.NIX_Spectra">NIX_Spectra</a></li>
<li><a title="NIX_Testing.NIX_Image" href="#NIX_Testing.NIX_Image">NIX_Image</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="NIX_Testing.NIX_Base.f_name"><code class="name">var <span class="ident">f_name</span></code></dt>
<dd>
<section class="desc"><p>Return an attribute of instance, which is of type owner.</p></section>
</dd>
<dt id="NIX_Testing.NIX_Base.full_path"><code class="name">var <span class="ident">full_path</span></code></dt>
<dd>
<section class="desc"><p>Return an attribute of instance, which is of type owner.</p></section>
</dd>
<dt id="NIX_Testing.NIX_Base.header"><code class="name">var <span class="ident">header</span></code></dt>
<dd>
<section class="desc"><p>Return an attribute of instance, which is of type owner.</p></section>
</dd>
<dt id="NIX_Testing.NIX_Base.test_id"><code class="name">var <span class="ident">test_id</span></code></dt>
<dd>
<section class="desc"><p>Return an attribute of instance, which is of type owner.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="NIX_Testing.NIX_Base.getImage"><code class="name flex">
<span>def <span class="ident">getImage</span></span>(<span>self, hdu=None, mask=None, dark=None, linearize=False, gain=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getImage(self, hdu=None, mask=None, dark=None, linearize=False, gain=None):

    hdul = fits.open(self.full_path)
    image = hdul[0].data*1. 
    hdul.close()
    # Handle exception where data format is (1, 2048, 2048)
    if image.shape[0] == 1:
        image = image[0,:,:]

    if dark is not None:
        image = image - dark.getImage()
    if linearize:
        image = self.linearize(image)
    if mask is not None:
        image = image * mask.getImage()
    if gain is not None:
        image *= gain
    return image</code></pre>
</details>
</dd>
<dt id="NIX_Testing.NIX_Base.linearize"><code class="name flex">
<span>def <span class="ident">linearize</span></span>(<span>self, image)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def linearize(self, image):
    f = open(&#39;linearity_coef&#39;, &#39;rb&#39;)
    pol = np.poly1d(pickle.load(f))
    f.close()

    image = pol(image)

    return image</code></pre>
</details>
</dd>
<dt id="NIX_Testing.NIX_Base.plotImage"><code class="name flex">
<span>def <span class="ident">plotImage</span></span>(<span>self, mask=None, dark=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotImage(self, mask=None, dark=None):

    plt.imshow(self.getImage(mask=mask, dark=dark))
    plt.gca().invert_yaxis()
    plt.show()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="NIX_Testing.NIX_Image"><code class="flex name class">
<span>class <span class="ident">NIX_Image</span></span>
<span>(</span><span>path, test_id=None, verbose=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NIX_Image(NIX_Base):

    def getMedian(self, dark=None, mask=None):

        if not hasattr(self, &#39;median&#39;):
            image = self.getImage(mask=mask, dark=dark)
            self.median = np.median(image)
        return self.median

    def getObjects(self, mask=None, search=None, thresh=500, minarea=20, force=False):
        
        if not hasattr(self, &#39;objects&#39;) or force:
            image = self.getImage(mask=mask)
            self.objects = sep.extract(image, thresh, minarea=minarea)

        if search is None:
            return self.objects
        else:
            # Caution. This will return first found object within the search radius
            for object in self.objects:
                if ((object[&#39;x&#39;] - search[&#39;x&#39;])**2 + (object[&#39;y&#39;] - search[&#39;y&#39;])**2 &lt; search[&#39;r&#39;]**2):
                    return object

    
    def plotDistortionPSF(self, grid=5, perc=95, mask=None, dark=None, linearize=False, title=None, clean=True, strehl=True, strehlWave=2.2, out_ims=None):

        objects = self.getObjects()
        im_sz = 30

        xs = np.array([obj[&#39;x&#39;] for obj in objects])
        ndxs = xs.argsort()
        objects = objects[ndxs]

        for i in range(grid):
            ys = np.array([obj[&#39;y&#39;] for obj in objects[grid*i:grid*(i+1)]])
            ndxs = ys.argsort()
            objects[grid*i:grid*(i+1)] = objects[grid*i:grid*(i+1)][ndxs]

        fig, axs = plt.subplots(grid, grid, figsize=(12,12))

        im = np.zeros([2048+2*im_sz, 2048+2*im_sz])
        im[im_sz:im_sz+2048, im_sz:im_sz+2048] = self.getImage(mask=mask, dark=dark, linearize=linearize)

        norm_im = ImageNormalize(im, interval=PercentileInterval(perc))

        if clean:
            im = badPixelInterpolate(im)

        strehl_str = &#39;&#39;
        fwhm_str = &#39;&#39;

        for i in range(grid):
            for j in range(grid):
                obj = objects[grid*j+i]
                x_c, y_c = int(obj[&#39;x&#39;])+im_sz, int(obj[&#39;y&#39;])+im_sz

                crop_im = im[y_c-im_sz:y_c+im_sz, x_c-im_sz:x_c+im_sz]
                if strehl:
                    airy_rad = 1.22*strehlWave*1e-6/8./np.pi*180.*60.*60.
                    strehl, crop_im, sig3 = strehlRatio(crop_im, strehlWave)
                    crop_im, _ = cosmicray_lacosmic(crop_im)
                    if out_ims is not None:
                        fits.PrimaryHDU(crop_im).writeto(out_ims % (grid-1-i, j), overwrite=True)
                    #strehl = HDRL_strehl(out_ims % (grid-1-i, j), strehlWave, 8./2., 1.116/2., 13., airy_rad, airy_rad*3, airy_rad*4)
                    strehl = HDRL_strehl2(crop_im, strehlWave, 8./2., 1.116/2., 13., airy_rad, airy_rad*3, airy_rad*4)
                    axs[grid-1-i][j].set_title(&#34;%.3f&#34; % strehl)
                
                strehl_str += &#39;%.4f &#39; % strehl 
                fwhm_str += &#39;%2.6f &#39; % (sig3/3.*2.35) 

                axs[grid-1-i][j].imshow(crop_im, cmap=&#39;gray&#39;, norm=norm_im)
                axs[grid-1-i][j].invert_yaxis()
                axs[grid-1-i][j].get_yaxis().set_ticks([])
                axs[grid-1-i][j].get_xaxis().set_ticks([])

            strehl_str += &#39;\n&#39;
            fwhm_str += &#39;\n&#39;

        if title is not None:
            fig.suptitle(title)

        return strehl_str, fwhm_str

    def plotObjects(self, mask=None, figsize=None):

        if figsize is not None:
            fig, ax = plt.subplots(figsize=figsize)
        else:
            fig, ax = plt.subplots()

        ax.imshow(self.getImage(mask=mask))
        ax.invert_yaxis()

        for object in self.objects:
        
            e = Ellipse(xy=(object[&#39;x&#39;], object[&#39;y&#39;]),
                        width=6*object[&#39;a&#39;],
                        height=6*object[&#39;b&#39;],
                        angle=object[&#39;theta&#39;] * 180. / np.pi)
            e.set_facecolor(&#39;none&#39;)
            e.set_edgecolor(&#39;red&#39;)
            ax.add_artist(e)
        
        plt.ylim([0, 2048])
        plt.xlim([0, 2048])
        plt.show()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="NIX_Testing.NIX_Base" href="#NIX_Testing.NIX_Base">NIX_Base</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="NIX_Testing.NIX_Image.getMedian"><code class="name flex">
<span>def <span class="ident">getMedian</span></span>(<span>self, dark=None, mask=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMedian(self, dark=None, mask=None):

    if not hasattr(self, &#39;median&#39;):
        image = self.getImage(mask=mask, dark=dark)
        self.median = np.median(image)
    return self.median</code></pre>
</details>
</dd>
<dt id="NIX_Testing.NIX_Image.getObjects"><code class="name flex">
<span>def <span class="ident">getObjects</span></span>(<span>self, mask=None, search=None, thresh=500, minarea=20, force=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getObjects(self, mask=None, search=None, thresh=500, minarea=20, force=False):
    
    if not hasattr(self, &#39;objects&#39;) or force:
        image = self.getImage(mask=mask)
        self.objects = sep.extract(image, thresh, minarea=minarea)

    if search is None:
        return self.objects
    else:
        # Caution. This will return first found object within the search radius
        for object in self.objects:
            if ((object[&#39;x&#39;] - search[&#39;x&#39;])**2 + (object[&#39;y&#39;] - search[&#39;y&#39;])**2 &lt; search[&#39;r&#39;]**2):
                return object</code></pre>
</details>
</dd>
<dt id="NIX_Testing.NIX_Image.plotDistortionPSF"><code class="name flex">
<span>def <span class="ident">plotDistortionPSF</span></span>(<span>self, grid=5, perc=95, mask=None, dark=None, linearize=False, title=None, clean=True, strehl=True, strehlWave=2.2, out_ims=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotDistortionPSF(self, grid=5, perc=95, mask=None, dark=None, linearize=False, title=None, clean=True, strehl=True, strehlWave=2.2, out_ims=None):

    objects = self.getObjects()
    im_sz = 30

    xs = np.array([obj[&#39;x&#39;] for obj in objects])
    ndxs = xs.argsort()
    objects = objects[ndxs]

    for i in range(grid):
        ys = np.array([obj[&#39;y&#39;] for obj in objects[grid*i:grid*(i+1)]])
        ndxs = ys.argsort()
        objects[grid*i:grid*(i+1)] = objects[grid*i:grid*(i+1)][ndxs]

    fig, axs = plt.subplots(grid, grid, figsize=(12,12))

    im = np.zeros([2048+2*im_sz, 2048+2*im_sz])
    im[im_sz:im_sz+2048, im_sz:im_sz+2048] = self.getImage(mask=mask, dark=dark, linearize=linearize)

    norm_im = ImageNormalize(im, interval=PercentileInterval(perc))

    if clean:
        im = badPixelInterpolate(im)

    strehl_str = &#39;&#39;
    fwhm_str = &#39;&#39;

    for i in range(grid):
        for j in range(grid):
            obj = objects[grid*j+i]
            x_c, y_c = int(obj[&#39;x&#39;])+im_sz, int(obj[&#39;y&#39;])+im_sz

            crop_im = im[y_c-im_sz:y_c+im_sz, x_c-im_sz:x_c+im_sz]
            if strehl:
                airy_rad = 1.22*strehlWave*1e-6/8./np.pi*180.*60.*60.
                strehl, crop_im, sig3 = strehlRatio(crop_im, strehlWave)
                crop_im, _ = cosmicray_lacosmic(crop_im)
                if out_ims is not None:
                    fits.PrimaryHDU(crop_im).writeto(out_ims % (grid-1-i, j), overwrite=True)
                #strehl = HDRL_strehl(out_ims % (grid-1-i, j), strehlWave, 8./2., 1.116/2., 13., airy_rad, airy_rad*3, airy_rad*4)
                strehl = HDRL_strehl2(crop_im, strehlWave, 8./2., 1.116/2., 13., airy_rad, airy_rad*3, airy_rad*4)
                axs[grid-1-i][j].set_title(&#34;%.3f&#34; % strehl)
            
            strehl_str += &#39;%.4f &#39; % strehl 
            fwhm_str += &#39;%2.6f &#39; % (sig3/3.*2.35) 

            axs[grid-1-i][j].imshow(crop_im, cmap=&#39;gray&#39;, norm=norm_im)
            axs[grid-1-i][j].invert_yaxis()
            axs[grid-1-i][j].get_yaxis().set_ticks([])
            axs[grid-1-i][j].get_xaxis().set_ticks([])

        strehl_str += &#39;\n&#39;
        fwhm_str += &#39;\n&#39;

    if title is not None:
        fig.suptitle(title)

    return strehl_str, fwhm_str</code></pre>
</details>
</dd>
<dt id="NIX_Testing.NIX_Image.plotObjects"><code class="name flex">
<span>def <span class="ident">plotObjects</span></span>(<span>self, mask=None, figsize=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotObjects(self, mask=None, figsize=None):

    if figsize is not None:
        fig, ax = plt.subplots(figsize=figsize)
    else:
        fig, ax = plt.subplots()

    ax.imshow(self.getImage(mask=mask))
    ax.invert_yaxis()

    for object in self.objects:
    
        e = Ellipse(xy=(object[&#39;x&#39;], object[&#39;y&#39;]),
                    width=6*object[&#39;a&#39;],
                    height=6*object[&#39;b&#39;],
                    angle=object[&#39;theta&#39;] * 180. / np.pi)
        e.set_facecolor(&#39;none&#39;)
        e.set_edgecolor(&#39;red&#39;)
        ax.add_artist(e)
    
    plt.ylim([0, 2048])
    plt.xlim([0, 2048])
    plt.show()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="NIX_Testing.NIX_Base" href="#NIX_Testing.NIX_Base">NIX_Base</a></b></code>:
<ul class="hlist">
<li><code><a title="NIX_Testing.NIX_Base.f_name" href="#NIX_Testing.NIX_Base.f_name">f_name</a></code></li>
<li><code><a title="NIX_Testing.NIX_Base.full_path" href="#NIX_Testing.NIX_Base.full_path">full_path</a></code></li>
<li><code><a title="NIX_Testing.NIX_Base.header" href="#NIX_Testing.NIX_Base.header">header</a></code></li>
<li><code><a title="NIX_Testing.NIX_Base.test_id" href="#NIX_Testing.NIX_Base.test_id">test_id</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="NIX_Testing.NIX_Image_List"><code class="flex name class">
<span>class <span class="ident">NIX_Image_List</span></span>
<span>(</span><span>config)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NIX_Image_List:

    def __init__(self, config):

        self.NIX_Files = []
        self.config = config
        self.loadFiles()
        self.Filtered = self.NIX_Files

    def __getitem__(self, ndx):

        return self.Filtered[ndx]

    def __len__(self):

        return len(self.Filtered)

    def loadFiles(self):

        if &#39;prefix&#39; in self.config:
            prefix = True
        else:
            prefix = False

        if &#39;test_ids&#39; in self.config:

            for test_id in self.config[&#39;test_ids&#39;]:
                full_path = self.config[&#39;data_dir&#39;] + &#39;/&#39;+ (&#39;%s-%s&#39; % tuple(test_id.split(&#39;-&#39;)[:2])) + &#39;/&#39; + test_id + &#39;/&#39;
                files = os.listdir(full_path)
                files.sort()

                for f_name in files:
                    if prefix:
                        if f_name.startswith(self.config[&#39;prefix&#39;]) and f_name.endswith(&#39;fits&#39;):
                            self.NIX_Files.append(NIX_Image(full_path + f_name, test_id=test_id))                        
                    else:
                        if f_name.endswith(&#39;fits&#39;):
                            self.NIX_Files.append(NIX_Image(full_path + f_name, test_id=test_id))

        else:

            full_path = self.config[&#39;data_dir&#39;] + &#39;/&#39;
            files = os.listdir(full_path)
            files.sort()

            for f_name in files:
                    if prefix:
                        if f_name.startswith(self.config[&#39;prefix&#39;]) and f_name.endswith(&#39;fits&#39;):
                            self.NIX_Files.append(NIX_Image(full_path + f_name))                        
                    else:
                        if f_name.endswith(&#39;fits&#39;):
                            self.NIX_Files.append(NIX_Image(full_path + f_name))
    

    def printTable(self, keywords, tbl_fmt):

        table_header =  [&#39;NDX&#39;, &#39;TEST_ID&#39;, &#39;FILENAME&#39;]
        table_header.extend([strip_prefix_from_keyword(keyword) for keyword in keywords])
        print((&#39;%4s&#39; + tbl_fmt) % tuple(table_header))
        
        ctr = 0 
        for File in self.NIX_Files:
            header = fits.getheader(File.full_path)
            out_list = [ctr, File.test_id, File.f_name]
            try:
                out_list.extend([header[keyword] for keyword in keywords])
                print((&#39;%04d&#39; + tbl_fmt) % tuple(out_list))
            except:
                out_list.extend(None for keyword in keywords)
                print((&#39;%04d&#39; + tbl_fmt) % tuple(out_list))
            ctr += 1

    def printFiltered(self, keywords, tbl_fmt):

        table_header =  [&#39;NDX&#39;, &#39;TEST_ID&#39;, &#39;FILENAME&#39;]
        table_header.extend([strip_prefix_from_keyword(keyword) for keyword in keywords])
        print((&#39;%4s&#39; + tbl_fmt) % tuple(table_header))
        
        ctr = 0 
        for File in self.Filtered:
            header = fits.getheader(File.full_path)
            out_list = [ctr, File.test_id, File.f_name]
            try:
                out_list.extend([header[keyword] for keyword in keywords])
                print((&#39;%04d&#39; + tbl_fmt) % tuple(out_list)) 
            except:
                out_list.extend(None for keyword in keywords)
                print((&#39;%04d&#39; + tbl_fmt) % tuple(out_list))
            ctr += 1


    # revisit later on for filtering data
    def filter(self, val):
        if isinstance(val, slice):
            self.Filtered = self.NIX_Files[val]

    def medianCombine(self, out=None):

        sz = len(self.Filtered)
        ims = np.zeros([2048, 2048, sz])

        for i in range(len(self.Filtered)):
            ims[:,:,i] = self.Filtered[i].getImage()

        if out is not None:
            fits.PrimaryHDU(np.median(ims, axis=2)).writeto(out, overwrite=True)
        
        return np.median(ims, axis=2)

    # very crude BP mask generation to be revisited later on
    def doBadPixelMask(self, thresh=20, out=None):
        
        im = self.medianCombine()

        im[np.where(im &lt; thresh)] = 1
        im[np.where(im &gt;= thresh)] = 0

        if out is not None:
            fits.PrimaryHDU(im).writeto(out, overwrite=True)
        
        return im

    def doLinearRegress(self, exps, select, cpu=1, dark=None, mask=None):

        sz = exps.shape[0]

        exps = np.tile(exps, 2048*2048)
        exps = exps.reshape([2048, 2048, sz])

        ims = self.getImage(select=select, mask=mask, dark=dark)

        angs, lins, Rs = self._multiLinearRegress(exps, ims, cpu=cpu)

        return angs, lins, Rs

    def getMedian(self, mask=None, dark=None):

        return [NI.getMedian(mask=mask, dark=dark) for NI in self.Filtered]

    def getImage(self, select=None, mask=None, dark=None):

        if select is not None:
            sz = select.shape[0]
        else:
            sz = len(self.Filtered)
        ims = np.zeros([2048, 2048, sz])

        if dark is None:
            darks = [None]*sz
        else:
            darks = [self.Filtered[i] for i in range(sz)]

        if select is not None:
            for i in range(sz):
                ims[:,:,i] = self.Filtered[select[i]].getImage(mask=mask, dark=darks[i])
        else:
            for i in range(sz):
                ims[:,:,i] = self.Filtered[i].getImage(mask=mask, dark=darks[i])

        return ims

    def getPixelVariance(self, mask=None, shift=True, gain=None):

        sz = len(self.Filtered)
        data = np.zeros([2048, 2048, sz])
        diff = np.zeros([2048, 2048, sz])

        for i in range(sz):
            data[:,:,i] = self.Filtered[i].getImage(mask=None, gain=gain)
            diff[:,:,i] = data[:,:,i] - data[:,:,0]
            diff[:,:,i] = np.median(diff[:,:,i])

        if shift:
            data[:,:,:] -= diff

        return np.var(data, axis=2, ddof=1), diff[0,0,:]

    def getObjects(self, mask=None, search=None, sepdict=None, thresh=500, minarea=20, force=False):
        
        if sepdict is not None:
            return [NI.getObjects(mask=mask, search=search, thresh=thresh, minarea=minarea, force=force)[sepdict] for NI in self.Filtered]
        else:
            return [NI.getObjects(mask=mask, search=search, thresh=thresh, minarea=minarea, force=force) for NI in self.Filtered]

    def getHeaderValue(self, keyword):

        return [fits.getheader(NI.full_path)[keyword] for NI in self.Filtered]

    def _multiLinearRegress(self, data1, data2, cpu=1):

        pb = ProgressBar(function=&#34;_multiLinearRegress&#34;)
        angs = np.zeros([2048, 2048])
        lins = np.zeros([2048, 2048])
        Rs = np.zeros([2048, 2048])
        pool = mp.Pool(cpu)
        for i in range(2048):
            arr1s = [data1[i,j,:] for j in range(2048)]
            arr2s = [data2[i,j,:] for j in range(2048)]
            out = pool.map(_singleLinearRegress, zip(arr1s, arr2s))
            for j in range(2048):
                angs[i,j], lins[i,j], Rs[i,j] = out[j][0], out[j][1], out[j][2]
            
            pb.report(i+1, 2048)

        return angs, lins, Rs</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="NIX_Testing.NIX_Image_List.doBadPixelMask"><code class="name flex">
<span>def <span class="ident">doBadPixelMask</span></span>(<span>self, thresh=20, out=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def doBadPixelMask(self, thresh=20, out=None):
    
    im = self.medianCombine()

    im[np.where(im &lt; thresh)] = 1
    im[np.where(im &gt;= thresh)] = 0

    if out is not None:
        fits.PrimaryHDU(im).writeto(out, overwrite=True)
    
    return im</code></pre>
</details>
</dd>
<dt id="NIX_Testing.NIX_Image_List.doLinearRegress"><code class="name flex">
<span>def <span class="ident">doLinearRegress</span></span>(<span>self, exps, select, cpu=1, dark=None, mask=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def doLinearRegress(self, exps, select, cpu=1, dark=None, mask=None):

    sz = exps.shape[0]

    exps = np.tile(exps, 2048*2048)
    exps = exps.reshape([2048, 2048, sz])

    ims = self.getImage(select=select, mask=mask, dark=dark)

    angs, lins, Rs = self._multiLinearRegress(exps, ims, cpu=cpu)

    return angs, lins, Rs</code></pre>
</details>
</dd>
<dt id="NIX_Testing.NIX_Image_List.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, val)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, val):
    if isinstance(val, slice):
        self.Filtered = self.NIX_Files[val]</code></pre>
</details>
</dd>
<dt id="NIX_Testing.NIX_Image_List.getHeaderValue"><code class="name flex">
<span>def <span class="ident">getHeaderValue</span></span>(<span>self, keyword)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getHeaderValue(self, keyword):

    return [fits.getheader(NI.full_path)[keyword] for NI in self.Filtered]</code></pre>
</details>
</dd>
<dt id="NIX_Testing.NIX_Image_List.getImage"><code class="name flex">
<span>def <span class="ident">getImage</span></span>(<span>self, select=None, mask=None, dark=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getImage(self, select=None, mask=None, dark=None):

    if select is not None:
        sz = select.shape[0]
    else:
        sz = len(self.Filtered)
    ims = np.zeros([2048, 2048, sz])

    if dark is None:
        darks = [None]*sz
    else:
        darks = [self.Filtered[i] for i in range(sz)]

    if select is not None:
        for i in range(sz):
            ims[:,:,i] = self.Filtered[select[i]].getImage(mask=mask, dark=darks[i])
    else:
        for i in range(sz):
            ims[:,:,i] = self.Filtered[i].getImage(mask=mask, dark=darks[i])

    return ims</code></pre>
</details>
</dd>
<dt id="NIX_Testing.NIX_Image_List.getMedian"><code class="name flex">
<span>def <span class="ident">getMedian</span></span>(<span>self, mask=None, dark=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMedian(self, mask=None, dark=None):

    return [NI.getMedian(mask=mask, dark=dark) for NI in self.Filtered]</code></pre>
</details>
</dd>
<dt id="NIX_Testing.NIX_Image_List.getObjects"><code class="name flex">
<span>def <span class="ident">getObjects</span></span>(<span>self, mask=None, search=None, sepdict=None, thresh=500, minarea=20, force=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getObjects(self, mask=None, search=None, sepdict=None, thresh=500, minarea=20, force=False):
    
    if sepdict is not None:
        return [NI.getObjects(mask=mask, search=search, thresh=thresh, minarea=minarea, force=force)[sepdict] for NI in self.Filtered]
    else:
        return [NI.getObjects(mask=mask, search=search, thresh=thresh, minarea=minarea, force=force) for NI in self.Filtered]</code></pre>
</details>
</dd>
<dt id="NIX_Testing.NIX_Image_List.getPixelVariance"><code class="name flex">
<span>def <span class="ident">getPixelVariance</span></span>(<span>self, mask=None, shift=True, gain=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPixelVariance(self, mask=None, shift=True, gain=None):

    sz = len(self.Filtered)
    data = np.zeros([2048, 2048, sz])
    diff = np.zeros([2048, 2048, sz])

    for i in range(sz):
        data[:,:,i] = self.Filtered[i].getImage(mask=None, gain=gain)
        diff[:,:,i] = data[:,:,i] - data[:,:,0]
        diff[:,:,i] = np.median(diff[:,:,i])

    if shift:
        data[:,:,:] -= diff

    return np.var(data, axis=2, ddof=1), diff[0,0,:]</code></pre>
</details>
</dd>
<dt id="NIX_Testing.NIX_Image_List.loadFiles"><code class="name flex">
<span>def <span class="ident">loadFiles</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadFiles(self):

    if &#39;prefix&#39; in self.config:
        prefix = True
    else:
        prefix = False

    if &#39;test_ids&#39; in self.config:

        for test_id in self.config[&#39;test_ids&#39;]:
            full_path = self.config[&#39;data_dir&#39;] + &#39;/&#39;+ (&#39;%s-%s&#39; % tuple(test_id.split(&#39;-&#39;)[:2])) + &#39;/&#39; + test_id + &#39;/&#39;
            files = os.listdir(full_path)
            files.sort()

            for f_name in files:
                if prefix:
                    if f_name.startswith(self.config[&#39;prefix&#39;]) and f_name.endswith(&#39;fits&#39;):
                        self.NIX_Files.append(NIX_Image(full_path + f_name, test_id=test_id))                        
                else:
                    if f_name.endswith(&#39;fits&#39;):
                        self.NIX_Files.append(NIX_Image(full_path + f_name, test_id=test_id))

    else:

        full_path = self.config[&#39;data_dir&#39;] + &#39;/&#39;
        files = os.listdir(full_path)
        files.sort()

        for f_name in files:
                if prefix:
                    if f_name.startswith(self.config[&#39;prefix&#39;]) and f_name.endswith(&#39;fits&#39;):
                        self.NIX_Files.append(NIX_Image(full_path + f_name))                        
                else:
                    if f_name.endswith(&#39;fits&#39;):
                        self.NIX_Files.append(NIX_Image(full_path + f_name))</code></pre>
</details>
</dd>
<dt id="NIX_Testing.NIX_Image_List.medianCombine"><code class="name flex">
<span>def <span class="ident">medianCombine</span></span>(<span>self, out=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def medianCombine(self, out=None):

    sz = len(self.Filtered)
    ims = np.zeros([2048, 2048, sz])

    for i in range(len(self.Filtered)):
        ims[:,:,i] = self.Filtered[i].getImage()

    if out is not None:
        fits.PrimaryHDU(np.median(ims, axis=2)).writeto(out, overwrite=True)
    
    return np.median(ims, axis=2)</code></pre>
</details>
</dd>
<dt id="NIX_Testing.NIX_Image_List.printFiltered"><code class="name flex">
<span>def <span class="ident">printFiltered</span></span>(<span>self, keywords, tbl_fmt)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printFiltered(self, keywords, tbl_fmt):

    table_header =  [&#39;NDX&#39;, &#39;TEST_ID&#39;, &#39;FILENAME&#39;]
    table_header.extend([strip_prefix_from_keyword(keyword) for keyword in keywords])
    print((&#39;%4s&#39; + tbl_fmt) % tuple(table_header))
    
    ctr = 0 
    for File in self.Filtered:
        header = fits.getheader(File.full_path)
        out_list = [ctr, File.test_id, File.f_name]
        try:
            out_list.extend([header[keyword] for keyword in keywords])
            print((&#39;%04d&#39; + tbl_fmt) % tuple(out_list)) 
        except:
            out_list.extend(None for keyword in keywords)
            print((&#39;%04d&#39; + tbl_fmt) % tuple(out_list))
        ctr += 1</code></pre>
</details>
</dd>
<dt id="NIX_Testing.NIX_Image_List.printTable"><code class="name flex">
<span>def <span class="ident">printTable</span></span>(<span>self, keywords, tbl_fmt)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printTable(self, keywords, tbl_fmt):

    table_header =  [&#39;NDX&#39;, &#39;TEST_ID&#39;, &#39;FILENAME&#39;]
    table_header.extend([strip_prefix_from_keyword(keyword) for keyword in keywords])
    print((&#39;%4s&#39; + tbl_fmt) % tuple(table_header))
    
    ctr = 0 
    for File in self.NIX_Files:
        header = fits.getheader(File.full_path)
        out_list = [ctr, File.test_id, File.f_name]
        try:
            out_list.extend([header[keyword] for keyword in keywords])
            print((&#39;%04d&#39; + tbl_fmt) % tuple(out_list))
        except:
            out_list.extend(None for keyword in keywords)
            print((&#39;%04d&#39; + tbl_fmt) % tuple(out_list))
        ctr += 1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="NIX_Testing.NIX_Spectra"><code class="flex name class">
<span>class <span class="ident">NIX_Spectra</span></span>
<span>(</span><span>path, test_id=None, verbose=False)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NIX_Spectra(NIX_Base):
    
    def _singleLineFit(self, xx, yy, window=10):

        from lmfit.models import GaussianModel, ConstantModel

        model = GaussianModel()+ConstantModel()
        pars = ConstantModel().make_params()
        pars += GaussianModel().guess(yy, x=xx)
        out = model.fit(yy, pars, x=xx)

        return out

    def _multiLineFitFromTable(self, nlines=20):

        import pandas as pd
        from lmfit.models import GaussianModel, LorentzianModel

        line_data = pd.read_csv(&#39;data/ThAr_lines.csv&#39;, header=None)
        line_data = line_data.sort_values(4, ascending=False)
        line_data = np.array(line_data[2])

        line_data = line_data[np.where((line_data &gt; 3090) &amp; (line_data &lt; 3900))[0]]

        plt.figure(figsize=(16,4))

        model_l = []

        for i in range(nlines):

            model = GaussianModel(prefix=&#34;l%02d_&#34; % i)
            model_l.append(model)

            if i == 0:
                pars = model.make_params()
            else:
                pars.update(model.make_params())

            #print pars
            plt.plot([line_data[i], line_data[i]], [0, 1e6], &#39;k--&#39;)

            pars[&#39;l%02d_center&#39; % i].set(value=line_data[i], 
                min=(line_data[i]-1.), max=(line_data[i]+1.))
            pars[&#39;l%02d_sigma&#39; % i].set(value=1.4, max=2.5, min=1.)
            pars[&#39;l%02d_amplitude&#39; % i].set(value=1e6)

        print(&#34;%20s %20s %20s&#34; % (&#34;Original(nm)&#34;, &#34;Measured(nm)&#34;, &#34;FWHM(nm)&#34;))
        for i in range(nlines):
            if i == 0:
                mod = model_l[i]
            else:
                mod += model_l[i]
 
        init = mod.eval(pars, x=self.wave)
        out=mod.fit((self.spectra1d-self.continuum(self.wave)), pars, x=self.wave)

        for i in range(nlines):
            print(&#34;%20.2f %20.2f %20.5f&#34; % (line_data[i], 
                out.best_values[&#34;l%02d_center&#34; % i], out.best_values[&#34;l%02d_sigma&#34; % i]*2.35))


        #print out.fit_report()
        plt.plot(self.wave, out.best_fit)
        plt.plot(self.wave, self.spectra1d - self.continuum(self.wave))
        plt.show()

    def _polFit(self, xx, yy, order):

        from lmfit.models import PolynomialModel

        model = PolynomialModel(order)
        pars = model.guess(yy, x=xx)
        out = model.fit(yy, pars, x=xx)
        
        return out

    def _continuumFit(self, method=&#39;polynomial&#39;, order=5, smooth=6):

        import pandas as pd

        line_data = pd.read_csv(&#39;data/ThAr_lines.csv&#39;, header=None)
        line_data = line_data.sort_values(4, ascending=False)
        line_data = np.array(line_data[2])

        self.spectraFiltered = self.spectra1d
        self.waveFiltered = self.wave

        for i in range(50):
            ndx = np.where(np.abs(self.waveFiltered - line_data[i]) &lt; 5)[0]
            self.spectraFiltered = np.delete(self.spectraFiltered, ndx)
            self.waveFiltered = np.delete(self.waveFiltered, ndx)
            #plt.plot([line_data[i], line_data[i]], [0, 1.2e6], &#39;r--&#39;)

        if method == &#34;polynomial&#34;:
            from lmfit.models import PolynomialModel
            model = PolynomialModel(order)
            pars = model.guess(self.spectraFiltered, x=self.waveFiltered)
            out = model.fit(self.spectraFiltered, pars, x=self.waveFiltered)
            self.continuum = np.poly1d([out.best_values[&#39;c%d&#39; % i] for i in range(order+1)[::-1]])
        elif method == &#34;spline&#34;:
            from scipy.interpolate import UnivariateSpline
            self.continuum = UnivariateSpline(self.waveFiltered, self.spectraFiltered, 
                w=1/self.spectraFiltered, k=order, s=smooth)

    def getOrderTracing(self, bright_line=None, mask=None, dark=None):

        window = 10

        if bright_line is not None:
            image = self.getImage(mask=mask, dark=dark)
            xys = bright_line[&#39;xys&#39;]
            centers = []
            plt.figure(figsize=(4*2, 4))
            for i in range(2):
                yy = image[xys[i][1]-window:xys[i][1]+window, xys[i][0]]
                xx = np.arange(xys[i][1]-window,xys[i][1]+window)
                out = self._singleLineFit(xx, yy, window=window) 
                centers.append(out.best_values[&#39;center&#39;])

                plt.subplot(1,2,i+1)
                plt.plot(xx, yy, &#39;k&#39;)
                plt.plot(xx, out.best_fit, &#39;r&#39;)

            plt.show()
            
        self.A = (centers[1]-centers[0])/(xys[1][0] - xys[0][0])

    def getSpectra1D(self, bright_line=None, mask=None, dark=None):

        if not hasattr(self, &#39;A&#39;):
            self.getOrderTracing(bright_line=bright_line, mask=mask, dark=dark)

        image = self.getImage(mask=mask, dark=dark)

        X = np.arange(2048)
        XX, YY = np.meshgrid(X, X)

        B = YY-self.A*XX
        B = np.floor(B).astype(int)

        spec1d = np.zeros(2048)

        for i in range(2048):
            for j in range(600, 1600):
                spec1d[B[i,j]] += image[i,j]

        plt.figure(figsize=(16, 4))

        plt.plot(X, spec1d)
        plt.show()

        self.spectra1d = spec1d

    def subtractContinuum(self, method=&#39;polynomial&#39;, order=5, smooth=6):

        plt.figure(figsize=(16, 4))
        out = self._continuumFit(method=method, order=order, smooth=smooth)

        plt.title(&#39;Continuum Model&#39;)
        plt.plot(self.wave, self.spectra1d)
        plt.plot(self.wave, self.continuum(self.wave))
        plt.show()
 
        plt.figure(figsize=(16, 4))
        plt.title(&#39;Continuum Subtracted&#39;)
        plt.plot(self.wave, self.spectra1d - self.continuum(self.wave))
        plt.show()

    def calibrate(self, ref_lines=None, mask=None, dark=None, order=2):
        
        window = 10

        if ref_lines is not None:
            image = self.getImage(mask=mask, dark=dark)
            sz = len(ref_lines)
            plt.figure(figsize=(4*sz, 4))
            xs = [ref_line[&#39;x&#39;] for ref_line in ref_lines]
            waves = [ref_line[&#39;wave&#39;] for ref_line in ref_lines]
            for i in range(sz):
                yy = self.spectra1d[xs[i]-window:xs[i]+window]
                xx = np.arange(xs[i]-window,xs[i]+window)
                out = self._singleLineFit(xx, yy, window=window) 
                xs[i] = out.best_values[&#39;center&#39;]

                plt.subplot(1,sz,i+1)
                plt.plot(xx, yy, &#39;k&#39;)
                plt.plot(xx, out.best_fit, &#39;r&#39;)

            plt.show()
        
        out = self._polFit(xs, waves, order=order)

        print(out.fit_report())

        xx = np.arange(2048)
        
        waveSol = np.poly1d(out.best_values.values())
        self.wave = waveSol(xx)

        plt.figure(figsize=(16, 4))
        plt.plot(self.wave, self.spectra1d)
        plt.show()

    def extract(self, ref_lines, mask=None, dark=None):
        
        spectra2d = self.getImage(mask=mask, dark=dark)
        self.plotImage(mask=mask, dark=dark)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="NIX_Testing.NIX_Base" href="#NIX_Testing.NIX_Base">NIX_Base</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="NIX_Testing.NIX_Spectra.calibrate"><code class="name flex">
<span>def <span class="ident">calibrate</span></span>(<span>self, ref_lines=None, mask=None, dark=None, order=2)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calibrate(self, ref_lines=None, mask=None, dark=None, order=2):
    
    window = 10

    if ref_lines is not None:
        image = self.getImage(mask=mask, dark=dark)
        sz = len(ref_lines)
        plt.figure(figsize=(4*sz, 4))
        xs = [ref_line[&#39;x&#39;] for ref_line in ref_lines]
        waves = [ref_line[&#39;wave&#39;] for ref_line in ref_lines]
        for i in range(sz):
            yy = self.spectra1d[xs[i]-window:xs[i]+window]
            xx = np.arange(xs[i]-window,xs[i]+window)
            out = self._singleLineFit(xx, yy, window=window) 
            xs[i] = out.best_values[&#39;center&#39;]

            plt.subplot(1,sz,i+1)
            plt.plot(xx, yy, &#39;k&#39;)
            plt.plot(xx, out.best_fit, &#39;r&#39;)

        plt.show()
    
    out = self._polFit(xs, waves, order=order)

    print(out.fit_report())

    xx = np.arange(2048)
    
    waveSol = np.poly1d(out.best_values.values())
    self.wave = waveSol(xx)

    plt.figure(figsize=(16, 4))
    plt.plot(self.wave, self.spectra1d)
    plt.show()</code></pre>
</details>
</dd>
<dt id="NIX_Testing.NIX_Spectra.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, ref_lines, mask=None, dark=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract(self, ref_lines, mask=None, dark=None):
    
    spectra2d = self.getImage(mask=mask, dark=dark)
    self.plotImage(mask=mask, dark=dark)</code></pre>
</details>
</dd>
<dt id="NIX_Testing.NIX_Spectra.getOrderTracing"><code class="name flex">
<span>def <span class="ident">getOrderTracing</span></span>(<span>self, bright_line=None, mask=None, dark=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getOrderTracing(self, bright_line=None, mask=None, dark=None):

    window = 10

    if bright_line is not None:
        image = self.getImage(mask=mask, dark=dark)
        xys = bright_line[&#39;xys&#39;]
        centers = []
        plt.figure(figsize=(4*2, 4))
        for i in range(2):
            yy = image[xys[i][1]-window:xys[i][1]+window, xys[i][0]]
            xx = np.arange(xys[i][1]-window,xys[i][1]+window)
            out = self._singleLineFit(xx, yy, window=window) 
            centers.append(out.best_values[&#39;center&#39;])

            plt.subplot(1,2,i+1)
            plt.plot(xx, yy, &#39;k&#39;)
            plt.plot(xx, out.best_fit, &#39;r&#39;)

        plt.show()
        
    self.A = (centers[1]-centers[0])/(xys[1][0] - xys[0][0])</code></pre>
</details>
</dd>
<dt id="NIX_Testing.NIX_Spectra.getSpectra1D"><code class="name flex">
<span>def <span class="ident">getSpectra1D</span></span>(<span>self, bright_line=None, mask=None, dark=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSpectra1D(self, bright_line=None, mask=None, dark=None):

    if not hasattr(self, &#39;A&#39;):
        self.getOrderTracing(bright_line=bright_line, mask=mask, dark=dark)

    image = self.getImage(mask=mask, dark=dark)

    X = np.arange(2048)
    XX, YY = np.meshgrid(X, X)

    B = YY-self.A*XX
    B = np.floor(B).astype(int)

    spec1d = np.zeros(2048)

    for i in range(2048):
        for j in range(600, 1600):
            spec1d[B[i,j]] += image[i,j]

    plt.figure(figsize=(16, 4))

    plt.plot(X, spec1d)
    plt.show()

    self.spectra1d = spec1d</code></pre>
</details>
</dd>
<dt id="NIX_Testing.NIX_Spectra.subtractContinuum"><code class="name flex">
<span>def <span class="ident">subtractContinuum</span></span>(<span>self, method='polynomial', order=5, smooth=6)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subtractContinuum(self, method=&#39;polynomial&#39;, order=5, smooth=6):

    plt.figure(figsize=(16, 4))
    out = self._continuumFit(method=method, order=order, smooth=smooth)

    plt.title(&#39;Continuum Model&#39;)
    plt.plot(self.wave, self.spectra1d)
    plt.plot(self.wave, self.continuum(self.wave))
    plt.show()

    plt.figure(figsize=(16, 4))
    plt.title(&#39;Continuum Subtracted&#39;)
    plt.plot(self.wave, self.spectra1d - self.continuum(self.wave))
    plt.show()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="NIX_Testing.NIX_Base" href="#NIX_Testing.NIX_Base">NIX_Base</a></b></code>:
<ul class="hlist">
<li><code><a title="NIX_Testing.NIX_Base.f_name" href="#NIX_Testing.NIX_Base.f_name">f_name</a></code></li>
<li><code><a title="NIX_Testing.NIX_Base.full_path" href="#NIX_Testing.NIX_Base.full_path">full_path</a></code></li>
<li><code><a title="NIX_Testing.NIX_Base.header" href="#NIX_Testing.NIX_Base.header">header</a></code></li>
<li><code><a title="NIX_Testing.NIX_Base.test_id" href="#NIX_Testing.NIX_Base.test_id">test_id</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="NIX_Testing.ProgressBar"><code class="flex name class">
<span>class <span class="ident">ProgressBar</span></span>
<span>(</span><span>function=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ProgressBar:

    __slots__ = (&#34;t_start&#34;, &#34;function&#34;)

    def __init__(self, function=None):
        self.t_start = time.time()
        if function is not None:
            self.function = function
        else:
            self.function = &#34;&#34;

    def init(self, function=None):
        self.__init__(function=function)

    def report(self, current, full):
        progress = float(current)/full*100
        bar_done = int(round(progress/5.))
        t_now = time.time()
        t_elapsed = t_now-self.t_start
        t_full = t_elapsed/progress*100

        clear_output(wait=True)
        print(&#34;%s ==&gt; [%s%s] %3d%% %s/%s&#34; % (self.function, &#34;#&#34;*bar_done, &#39;-&#39;*(20-bar_done), progress,
            self._formatTime(t_elapsed), self._formatTime(t_full)))

    def _formatTime(self, t):

        mins = t / 60.
        secs = t % 60

        return &#34;%02d:%02d&#34; % (mins, secs)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="NIX_Testing.ProgressBar.function"><code class="name">var <span class="ident">function</span></code></dt>
<dd>
<section class="desc"><p>Return an attribute of instance, which is of type owner.</p></section>
</dd>
<dt id="NIX_Testing.ProgressBar.t_start"><code class="name">var <span class="ident">t_start</span></code></dt>
<dd>
<section class="desc"><p>Return an attribute of instance, which is of type owner.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="NIX_Testing.ProgressBar.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>self, function=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init(self, function=None):
    self.__init__(function=function)</code></pre>
</details>
</dd>
<dt id="NIX_Testing.ProgressBar.report"><code class="name flex">
<span>def <span class="ident">report</span></span>(<span>self, current, full)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def report(self, current, full):
    progress = float(current)/full*100
    bar_done = int(round(progress/5.))
    t_now = time.time()
    t_elapsed = t_now-self.t_start
    t_full = t_elapsed/progress*100

    clear_output(wait=True)
    print(&#34;%s ==&gt; [%s%s] %3d%% %s/%s&#34; % (self.function, &#34;#&#34;*bar_done, &#39;-&#39;*(20-bar_done), progress,
        self._formatTime(t_elapsed), self._formatTime(t_full)))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="NIX_Testing.HDRL" href="HDRL.html">NIX_Testing.HDRL</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="NIX_Testing.Gaussian2D" href="#NIX_Testing.Gaussian2D">Gaussian2D</a></code></li>
<li><code><a title="NIX_Testing.Gaussian2D_errf" href="#NIX_Testing.Gaussian2D_errf">Gaussian2D_errf</a></code></li>
<li><code><a title="NIX_Testing.HDRL_strehl" href="#NIX_Testing.HDRL_strehl">HDRL_strehl</a></code></li>
<li><code><a title="NIX_Testing.HDRL_strehl2" href="#NIX_Testing.HDRL_strehl2">HDRL_strehl2</a></code></li>
<li><code><a title="NIX_Testing.badPixelInterpolate" href="#NIX_Testing.badPixelInterpolate">badPixelInterpolate</a></code></li>
<li><code><a title="NIX_Testing.doGridAnalysis" href="#NIX_Testing.doGridAnalysis">doGridAnalysis</a></code></li>
<li><code><a title="NIX_Testing.getDiffractionPattern" href="#NIX_Testing.getDiffractionPattern">getDiffractionPattern</a></code></li>
<li><code><a title="NIX_Testing.strehlRatio" href="#NIX_Testing.strehlRatio">strehlRatio</a></code></li>
<li><code><a title="NIX_Testing.strip_prefix_from_keyword" href="#NIX_Testing.strip_prefix_from_keyword">strip_prefix_from_keyword</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="NIX_Testing.NIX_Base" href="#NIX_Testing.NIX_Base">NIX_Base</a></code></h4>
<ul class="two-column">
<li><code><a title="NIX_Testing.NIX_Base.f_name" href="#NIX_Testing.NIX_Base.f_name">f_name</a></code></li>
<li><code><a title="NIX_Testing.NIX_Base.full_path" href="#NIX_Testing.NIX_Base.full_path">full_path</a></code></li>
<li><code><a title="NIX_Testing.NIX_Base.getImage" href="#NIX_Testing.NIX_Base.getImage">getImage</a></code></li>
<li><code><a title="NIX_Testing.NIX_Base.header" href="#NIX_Testing.NIX_Base.header">header</a></code></li>
<li><code><a title="NIX_Testing.NIX_Base.linearize" href="#NIX_Testing.NIX_Base.linearize">linearize</a></code></li>
<li><code><a title="NIX_Testing.NIX_Base.plotImage" href="#NIX_Testing.NIX_Base.plotImage">plotImage</a></code></li>
<li><code><a title="NIX_Testing.NIX_Base.test_id" href="#NIX_Testing.NIX_Base.test_id">test_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="NIX_Testing.NIX_Image" href="#NIX_Testing.NIX_Image">NIX_Image</a></code></h4>
<ul class="">
<li><code><a title="NIX_Testing.NIX_Image.getMedian" href="#NIX_Testing.NIX_Image.getMedian">getMedian</a></code></li>
<li><code><a title="NIX_Testing.NIX_Image.getObjects" href="#NIX_Testing.NIX_Image.getObjects">getObjects</a></code></li>
<li><code><a title="NIX_Testing.NIX_Image.plotDistortionPSF" href="#NIX_Testing.NIX_Image.plotDistortionPSF">plotDistortionPSF</a></code></li>
<li><code><a title="NIX_Testing.NIX_Image.plotObjects" href="#NIX_Testing.NIX_Image.plotObjects">plotObjects</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="NIX_Testing.NIX_Image_List" href="#NIX_Testing.NIX_Image_List">NIX_Image_List</a></code></h4>
<ul class="two-column">
<li><code><a title="NIX_Testing.NIX_Image_List.doBadPixelMask" href="#NIX_Testing.NIX_Image_List.doBadPixelMask">doBadPixelMask</a></code></li>
<li><code><a title="NIX_Testing.NIX_Image_List.doLinearRegress" href="#NIX_Testing.NIX_Image_List.doLinearRegress">doLinearRegress</a></code></li>
<li><code><a title="NIX_Testing.NIX_Image_List.filter" href="#NIX_Testing.NIX_Image_List.filter">filter</a></code></li>
<li><code><a title="NIX_Testing.NIX_Image_List.getHeaderValue" href="#NIX_Testing.NIX_Image_List.getHeaderValue">getHeaderValue</a></code></li>
<li><code><a title="NIX_Testing.NIX_Image_List.getImage" href="#NIX_Testing.NIX_Image_List.getImage">getImage</a></code></li>
<li><code><a title="NIX_Testing.NIX_Image_List.getMedian" href="#NIX_Testing.NIX_Image_List.getMedian">getMedian</a></code></li>
<li><code><a title="NIX_Testing.NIX_Image_List.getObjects" href="#NIX_Testing.NIX_Image_List.getObjects">getObjects</a></code></li>
<li><code><a title="NIX_Testing.NIX_Image_List.getPixelVariance" href="#NIX_Testing.NIX_Image_List.getPixelVariance">getPixelVariance</a></code></li>
<li><code><a title="NIX_Testing.NIX_Image_List.loadFiles" href="#NIX_Testing.NIX_Image_List.loadFiles">loadFiles</a></code></li>
<li><code><a title="NIX_Testing.NIX_Image_List.medianCombine" href="#NIX_Testing.NIX_Image_List.medianCombine">medianCombine</a></code></li>
<li><code><a title="NIX_Testing.NIX_Image_List.printFiltered" href="#NIX_Testing.NIX_Image_List.printFiltered">printFiltered</a></code></li>
<li><code><a title="NIX_Testing.NIX_Image_List.printTable" href="#NIX_Testing.NIX_Image_List.printTable">printTable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="NIX_Testing.NIX_Spectra" href="#NIX_Testing.NIX_Spectra">NIX_Spectra</a></code></h4>
<ul class="">
<li><code><a title="NIX_Testing.NIX_Spectra.calibrate" href="#NIX_Testing.NIX_Spectra.calibrate">calibrate</a></code></li>
<li><code><a title="NIX_Testing.NIX_Spectra.extract" href="#NIX_Testing.NIX_Spectra.extract">extract</a></code></li>
<li><code><a title="NIX_Testing.NIX_Spectra.getOrderTracing" href="#NIX_Testing.NIX_Spectra.getOrderTracing">getOrderTracing</a></code></li>
<li><code><a title="NIX_Testing.NIX_Spectra.getSpectra1D" href="#NIX_Testing.NIX_Spectra.getSpectra1D">getSpectra1D</a></code></li>
<li><code><a title="NIX_Testing.NIX_Spectra.subtractContinuum" href="#NIX_Testing.NIX_Spectra.subtractContinuum">subtractContinuum</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="NIX_Testing.ProgressBar" href="#NIX_Testing.ProgressBar">ProgressBar</a></code></h4>
<ul class="">
<li><code><a title="NIX_Testing.ProgressBar.function" href="#NIX_Testing.ProgressBar.function">function</a></code></li>
<li><code><a title="NIX_Testing.ProgressBar.init" href="#NIX_Testing.ProgressBar.init">init</a></code></li>
<li><code><a title="NIX_Testing.ProgressBar.report" href="#NIX_Testing.ProgressBar.report">report</a></code></li>
<li><code><a title="NIX_Testing.ProgressBar.t_start" href="#NIX_Testing.ProgressBar.t_start">t_start</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>